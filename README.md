# Mirage - the **M**odest **I**ntermediate **R**epresent**A**tion **GE**nerator
Mirage is a bytecode emitter and (soon) interpreter designed to make it easier to write interpreted languages in Nim. \
It is made for the Bali JavaScript engine that will be used for Ferus. \
A lot of the bytecode instructions are shamelessly ripped off from Lua :^) \

# Basic bytecode generation example
The following code generates the intermediate representation of a program that instantiates a few values in a "main" function/clause.
```nim
import mirage/[atom, ir/gen]

var generator = newCodeGenerator()
generator.opts.deadCodeElimination = true # Disable this if you want "unused write" warnings.

generator.enter("main")

generator.write(
  name = "hello",
  atom = str "hehehehaw",
  mutable = false
)

generator.write(
  name = "thing",
  atom = integer 32,
  mutable = false
)

generator.write(
  name = "very_useful_value",
  atom = integer 1337,
  mutable = false
)

generator.call(
  "print",
  args = @[
    str "hello world!"
  ],
  refs = @[
    generator.reference("thinge") # doesn't exist lol
  ]
)

generator.exit("main")

# Pass 1: basic optimizations (if enabled)
generator.compute()

# Pass 2: generate IR
let mir = generator.generateIR()

for warn in mir.warnings:
  echo "Warn: " & warn.message

echo mir.source
```
It returns an `IR` object that has all the warnings generated by the IR generator alongside the IR source itself.

# What it can do
- Emit bytecode
- Interpret bytecode
- Apply some rudimentary optimizations (only dead code elim. for now!)

Mirage is ~400 LoC and does most of the bytecode work already. We're probably never going to get as fast/efficient as LLVM which has millions of hours of manpower and research applied to it with millions of LoC.

# What it'll do
- Apply advanced optimizations (speculative execution, etc.) to the bytecode
- JIT compile stuff

# What it won't do, for now atleast.
- Be a real competitor to LLVM's JIT runtime
- Do the other things needed to write a programming language interpreter (tokenizer, parser, semantic rule applier, etc.)

# Why not add a semantic rule applier?
1. A lot of languages have very bizzare allowances on what they allow the programmer to do (take JavaScript's detached-from-reality "type" system for example)
2. I'm lazy
